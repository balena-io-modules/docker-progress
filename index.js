// Generated by CoffeeScript 1.11.1
(function() {
  var Docker, DockerProgress, Promise, Registry, RegistryV1, RegistryV2, _, calculatePercentage, getLongId, onProgressHandler, request,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  Promise = require('bluebird');

  Docker = require('docker-toolbelt');

  request = require('request');

  request = request.defaults({
    gzip: true,
    timeout: 30000
  });

  request = Promise.promisifyAll(request, {
    multiArgs: true
  });

  Registry = (function() {
    function Registry(registry, version1) {
      var i, match, port, ref;
      this.version = version1;
      match = registry.match(/^([^\/:]+)(?::([^\/]+))?$/);
      if (!match) {
        throw new Error("Could not parse the registry: " + registry);
      }
      i = match.length - 2, this.registry = match[i++], port = (ref = match[i++]) != null ? ref : 443;
      this.port = _.parseInt(port);
      if (_.isNaN(this.port)) {
        throw new TypeError("Port must be a valid integer, got '" + port + "'");
      }
      this.protocol = this.port === 443 ? 'https' : 'http';
    }

    Registry.prototype.get = function(path) {
      return request.getAsync(this.protocol + "://" + this.registry + ":" + this.port + path);
    };

    Registry.prototype.toString = function() {
      return this.registry + ":" + this.port;
    };

    return Registry;

  })();

  exports.RegistryV1 = RegistryV1 = (function(superClass) {
    extend(RegistryV1, superClass);

    function RegistryV1() {
      return RegistryV1.__super__.constructor.apply(this, arguments);
    }

    RegistryV1.prototype.getImageId = function(imageName, tagName) {
      return this.get("/v1/repositories/" + imageName + "/tags").spread((function(_this) {
        return function(res, data) {
          var tags;
          if (res.statusCode === 404) {
            throw new Error("No such image " + imageName + " on registry " + _this.registry);
          }
          if (res.statusCode >= 400) {
            throw new Error("Failed to get image tags of " + imageName + " from " + _this.registry + ". Status code: " + res.statusCode);
          }
          tags = JSON.parse(data);
          if (tags[tagName] == null) {
            throw new Error("Could not find tag " + tagName + " for image " + imageName);
          }
          return tags[tagName];
        };
      })(this));
    };

    RegistryV1.prototype.getImageHistory = function(imageId) {
      return this.get("/v1/images/" + imageId + "/ancestry").spread((function(_this) {
        return function(res, data) {
          var history;
          if (res.statusCode >= 400) {
            throw new Error("Failed to get image ancestry of " + imageId + " from " + _this.registry + ". Status code: " + res.statusCode);
          }
          history = JSON.parse(data);
          return history;
        };
      })(this));
    };

    RegistryV1.prototype.getImageDownloadSize = function(imageId) {
      return this.get("/v1/images/" + imageId + "/json").spread((function(_this) {
        return function(res, data) {
          if (res.statusCode >= 400) {
            throw new Error("Failed to get image download size of " + imageId + " from " + _this.registry + ". Status code: " + res.statusCode);
          }
          return parseInt(res.headers['x-docker-size']);
        };
      })(this));
    };

    RegistryV1.prototype.getLayerDownloadSizes = function(imageName, tagName) {
      var layerIds, layerSizes;
      layerSizes = {};
      layerIds = [];
      return this.getImageId(imageName, tagName).then((function(_this) {
        return function(imageId) {
          return _this.getImageHistory(imageId);
        };
      })(this)).map((function(_this) {
        return function(layerId) {
          layerIds.push(layerId);
          return _this.getImageDownloadSize(layerId).then(function(size) {
            return layerSizes[layerId] = size;
          });
        };
      })(this))["return"]([layerSizes, layerIds]);
    };

    return RegistryV1;

  })(Registry);

  exports.RegistryV2 = RegistryV2 = (function() {
    function RegistryV2(registry, version) {
      var i, match, port, ref;
      match = registry.match(/^([^\/:]+)(?::([^\/]+))?$/);
      if (!match) {
        throw new Error("Could not parse the registry: " + registry);
      }
      i = match.length - 2, this.registry = match[i++], port = (ref = match[i++]) != null ? ref : 443;
      this.port = _.parseInt(port);
      if (_.isNaN(this.port)) {
        throw new TypeError("Port must be a valid integer, got '" + port + "'");
      }
      this.protocol = this.port === 443 ? 'https' : 'http';
    }

    RegistryV2.prototype.get = function(path) {
      return request.getAsync(this.protocol + "://" + this.registry + ":" + this.port + path);
    };

    RegistryV2.prototype.head = function(path) {
      return request.headAsync(this.protocol + "://" + this.registry + ":" + this.port + path);
    };

    RegistryV2.prototype.getImageLayers = function(imageName, tagName) {
      return this.get("/v2/" + imageName + "/manifests/" + tagName).spread((function(_this) {
        return function(res, data) {
          if (res.statusCode >= 400) {
            throw new Error("Failed to get image ancestry of " + imageName + " from " + _this.registry + ". Status code: " + res.statusCode);
          }
          return _.map(JSON.parse(data).fsLayers, 'blobSum');
        };
      })(this));
    };

    RegistryV2.prototype.getLayerDownloadSize = function(imageName, blobId) {
      return this.head("/v2/" + imageName + "/blobs/" + blobId).spread((function(_this) {
        return function(res, data) {
          if (res.statusCode >= 400) {
            throw new Error("Failed to get image download size of " + imageName + " from " + _this.registry + ". Status code: " + res.statusCode);
          }
          return parseInt(res.headers['content-length']);
        };
      })(this));
    };

    RegistryV2.prototype.getLayerDownloadSizes = function(imageName, tagName) {
      var layerIds, layerSizes;
      layerSizes = {};
      layerIds = [];
      return this.getImageLayers(imageName, tagName).map((function(_this) {
        return function(blobId) {
          layerIds.unshift(blobId);
          return _this.getLayerDownloadSize(imageName, blobId).then(function(size) {
            return layerSizes[blobId] = size;
          });
        };
      })(this))["return"]([layerSizes, layerIds]);
    };

    return RegistryV2;

  })();

  calculatePercentage = function(completed, total) {
    var percentage;
    if (total == null) {
      percentage = 0;
    } else if (total === 0) {
      percentage = 100;
    } else {
      percentage = Math.min(100, Math.floor((100 * completed) / total));
    }
    return percentage;
  };

  onProgressHandler = function(onProgressPromise, fallbackOnProgress) {
    var evts, onProgress;
    evts = [];
    onProgress = function(evt) {
      return evts.push(evt);
    };
    onProgressPromise.then(function(resolvedOnProgress) {
      return onProgress = resolvedOnProgress;
    })["catch"](function(e) {
      console.warn('error', e);
      return onProgress = fallbackOnProgress;
    }).then(function() {
      return _.map(evts, function(evt) {
        try {
          return onProgress(evt);
        } catch (error) {}
      });
    });
    return function(evt) {
      return onProgress(evt);
    };
  };

  getLongId = function(shortId, layerIds) {
    var longId;
    if (shortId == null) {
      throw new Error('Progress event missing layer id. Progress not correct.');
    }
    longId = _.find(layerIds, function(id) {
      return _.startsWith(id, shortId);
    });
    if (longId == null) {
      throw new Error("Progress error: Unknown layer " + shortId + " referenced by docker. Progress not correct.");
    }
    return longId;
  };

  exports.DockerProgress = DockerProgress = (function() {
    function DockerProgress(dockerOpts) {
      if (!(this instanceof DockerProgress)) {
        return new DockerProgress(dockerOpts);
      }
      this.docker = new Docker(dockerOpts);
    }

    DockerProgress.prototype.pull = function(image, onProgress, callback) {
      var onProgressPromise;
      onProgressPromise = this.pullProgress(image, onProgress);
      onProgress = onProgressHandler(onProgressPromise, onProgress);
      return this.docker.pullAsync(image).then((function(_this) {
        return function(stream) {
          return Promise.fromCallback(function(callback) {
            return _this.docker.modem.followProgress(stream, callback, onProgress);
          });
        };
      })(this)).nodeify(callback);
    };

    DockerProgress.prototype.push = function(image, onProgress, options, callback) {
      var onProgressPromise;
      onProgressPromise = this.pushProgress(image, onProgress);
      onProgress = onProgressHandler(onProgressPromise, onProgress);
      return this.docker.getImage(image).pushAsync(options).then((function(_this) {
        return function(stream) {
          return Promise.fromCallback(function(callback) {
            return _this.docker.modem.followProgress(stream, callback, onProgress);
          });
        };
      })(this)).nodeify(callback);
    };

    DockerProgress.prototype.getRegistryAndName = function(image) {
      return this.docker.getRegistryAndName(image).then(function(arg) {
        var imageName, registry, tagName;
        registry = arg.registry, imageName = arg.imageName, tagName = arg.tagName;
        return request.getAsync("https://" + registry + "/v2").get(0).then(function(res) {
          if (res.statusCode === 404) {
            registry = new RegistryV1(registry);
          } else {
            registry = new RegistryV2(registry);
          }
          return {
            registry: registry,
            imageName: imageName,
            tagName: tagName
          };
        });
      });
    };

    DockerProgress.prototype.getLayerDownloadSizes = function(image) {
      return this.getRegistryAndName(image).then(function(arg) {
        var imageName, registry, tagName;
        registry = arg.registry, imageName = arg.imageName, tagName = arg.tagName;
        return registry.getLayerDownloadSizes(imageName, tagName);
      });
    };

    DockerProgress.prototype.getImageLayerSizes = function(image) {
      var lastLayer, layers;
      image = this.docker.getImage(image);
      layers = image.historyAsync();
      lastLayer = image.inspectAsync();
      return Promise.join(layers, lastLayer, function(layers, lastLayer) {
        layers.push(lastLayer);
        return _(layers).keyBy('Id').mapValues('Size').mapKeys(function(v, id) {
          return id.replace(/^sha256:/, '');
        }).value();
      });
    };

    DockerProgress.prototype.pullProgress = function(image, onProgress) {
      return this.getLayerDownloadSizes(image).spread(function(layerSizes, remoteLayerIds) {
        var completedSize, currentDownloadedSize, layerIds, totalSize;
        layerIds = {};
        totalSize = _.sum(_.values(layerSizes));
        completedSize = 0;
        currentDownloadedSize = {};
        return function(evt) {
          var downloadedSize, err, percentage, ref, remoteId, shortId, status;
          try {
            status = evt.status;
            shortId = evt.id;
            if ((evt.progressDetail != null) && (layerIds[shortId] == null)) {
              remoteId = remoteLayerIds.find(function(id) {
                return id.replace(/^sha256:/, '').startsWith(shortId);
              });
              if (remoteId == null) {
                remoteId = remoteLayerIds[_.size(layerIds)];
              }
              layerIds[shortId] = remoteId;
            }
            if (status === 'Downloading') {
              currentDownloadedSize[shortId] = evt.progressDetail.current;
            } else if (status === 'Download complete' || status === 'Already exists') {
              remoteId = layerIds[shortId];
              completedSize += layerSizes[remoteId];
              currentDownloadedSize[shortId] = 0;
            } else if (status.match(/^Status: Image is up to date for /)) {
              completedSize = totalSize;
              currentDownloadedSize = {};
            }
            downloadedSize = completedSize + _.sum(_.values(currentDownloadedSize));
            percentage = calculatePercentage(downloadedSize, totalSize);
            return onProgress(_.merge(evt, {
              downloadedSize: downloadedSize,
              totalSize: totalSize,
              percentage: percentage
            }));
          } catch (error) {
            err = error;
            console.warn('Progress error:', (ref = err.message) != null ? ref : err);
            return totalSize = null;
          }
        };
      });
    };

    DockerProgress.prototype.pushProgress = function(image, onProgress) {
      return this.getImageLayerSizes(image).then(function(layerSizes) {
        var completedSize, layerIds, layerPushedSize, totalSize;
        layerIds = _.keys(layerSizes);
        layerPushedSize = {};
        completedSize = 0;
        totalSize = _.sum(_.values(layerSizes));
        return function(evt) {
          var err, longId, percentage, pushMatch, pushedSize, ref, shortId, status;
          try {
            status = evt.status;
            shortId = evt.id;
            pushMatch = /Image (.*) already pushed/.exec(status);
            if (status === 'Pushing' && (evt.progressDetail.current != null)) {
              longId = getLongId(shortId, layerIds);
              if (longId != null) {
                layerPushedSize[longId] = evt.progressDetail.current;
              }
            } else if (status === 'Layer already exists' || status === 'Image successfully pushed' || pushMatch) {
              shortId || (shortId = pushMatch[1]);
              longId = getLongId(shortId, layerIds);
              if (longId != null) {
                completedSize += layerSizes[longId];
                layerPushedSize[longId] = 0;
              }
            }
            pushedSize = completedSize + _.sum(_.values(layerPushedSize));
            percentage = calculatePercentage(pushedSize, totalSize);
            return onProgress(_.merge(evt, {
              pushedSize: pushedSize,
              totalSize: totalSize,
              percentage: percentage
            }));
          } catch (error) {
            err = error;
            console.warn('Progress error:', (ref = err.message) != null ? ref : err);
            return totalSize = null;
          }
        };
      });
    };

    return DockerProgress;

  })();

}).call(this);
