// Generated by CoffeeScript 1.10.0
(function() {
  var Docker, DockerProgres, Promise, Registry, _, calculatePercentage, getRegistryAndName, humanize, request;

  _ = require('lodash');

  Promise = require('bluebird');

  Docker = require('dockerode');

  request = require('request');

  humanize = require('humanize');

  request = request.defaults({
    gzip: true,
    timeout: 30000
  });

  request = Promise.promisifyAll(request);

  Promise.promisifyAll(Docker.prototype);

  Promise.promisifyAll(Docker({}).getImage().constructor.prototype);

  Promise.promisifyAll(Docker({}).getContainer().constructor.prototype);

  Registry = (function() {
    function Registry(registry) {
      var m, match, port, ref;
      match = registry.match(/^([^\/:]+)(?::([^\/]+))?$/);
      if (!match) {
        throw new Error("Could not parse the registry: " + registry);
      }
      m = match[0], this.registry = match[1], port = (ref = match[2]) != null ? ref : 80;
      this.port = _.parseInt(port);
      if (_.isNaN(this.port)) {
        throw new TypeError("Port must be a valid integer, got '" + port + "'");
      }
      this.protocol = this.port === 443 ? 'https' : 'http';
    }

    Registry.prototype.get = function(path) {
      return request.getAsync(this.protocol + "://" + this.registry + ":" + this.port + path);
    };

    Registry.prototype.getImageId = function(imageName, tagName) {
      return this.get("/v1/repositories/" + imageName + "/tags").spread(function(res, data) {
        var tags;
        if (res.statusCode === 404) {
          throw new Error("No such image " + imageName + " on registry " + registry);
        }
        if (res.statusCode >= 400) {
          throw new Error("Failed to get image tags of " + imageName + " from " + registry + ". Status code: " + res.statusCode);
        }
        tags = JSON.parse(data);
        if (tags[tagName] == null) {
          throw new Error("Could not find tag " + tagName + " for image " + imageName);
        }
        return tags[tagName];
      });
    };

    Registry.prototype.getImageHistory = function(imageId) {
      return this.get("/v1/images/" + imageId + "/ancestry").spread(function(res, data) {
        var history;
        if (res.statusCode >= 400) {
          throw new Error("Failed to get image ancestry of " + imageId + " from " + registry + ". Status code: " + res.statusCode);
        }
        history = JSON.parse(data);
        return history;
      });
    };

    Registry.prototype.getImageDownloadSize = function(imageId) {
      return this.get("/v1/images/" + imageId + "/json").spread(function(res, data) {
        if (res.statusCode >= 400) {
          throw new Error("Failed to get image download size of " + imageId + " from " + registry + ". Status code: " + res.statusCode);
        }
        return parseInt(res.headers['x-docker-size']);
      });
    };

    return Registry;

  })();

  getRegistryAndName = Promise.method(function(image) {
    var imageName, m, match, ref, ref1, registry, tagName;
    match = image.match(/^(?:([^\/:]+(?::[^\/]+)?)\/)?([^\/:]+(?:\/[^\/:]+)?)(?::(.*))?$/);
    if (!match) {
      throw new Error("Could not parse the image: " + image);
    }
    m = match[0], registry = (ref = match[1]) != null ? ref : 'docker.io', imageName = match[2], tagName = (ref1 = match[3]) != null ? ref1 : 'latest';
    if (!imageName) {
      throw new Error('Invalid image name, expected domain.tld/repo/image format.');
    }
    registry = new Registry(registry);
    return {
      registry: registry,
      imageName: imageName,
      tagName: tagName
    };
  });

  calculatePercentage = function(completed, total) {
    var percentage;
    if (total == null) {
      percentage = 0;
    } else if (total === 0) {
      percentage = 100;
    } else {
      percentage = Math.floor((100 * completed) / total);
    }
    return percentage;
  };

  module.exports = DockerProgres = (function() {
    function DockerProgres(dockerOpts) {
      if (!(this instanceof DockerProgres)) {
        return new DockerProgres(dockerOpts);
      }
      this.docker = new Docker(dockerOpts);
    }

    DockerProgres.prototype.pull = function(image, onProgress, callback) {
      return Promise.join(this.docker.pullAsync(image), this.pullProgress(image, onProgress), (function(_this) {
        return function(stream, onProgress) {
          return Promise.fromNode(function(callback) {
            return _this.docker.modem.followProgress(stream, callback, onProgress);
          });
        };
      })(this)).nodeify(callback);
    };

    DockerProgres.prototype.push = function(image, onProgress, options, callback) {
      return Promise.join(this.docker.getImage(image).pushAsync(options), this.pushProgress(image, onProgress), (function(_this) {
        return function(stream, onProgress) {
          return Promise.fromNode(function(callback) {
            return _this.docker.modem.followProgress(stream, callback, onProgress);
          });
        };
      })(this)).nodeify(callback);
    };

    DockerProgres.prototype.imageExists = function(imageId) {
      return this.docker.getImage(imageId).inspectAsync()["return"](true)["catch"](function() {
        return false;
      });
    };

    DockerProgres.prototype.getLayerDownloadSizes = function(image) {
      return getRegistryAndName(image).then((function(_this) {
        return function(arg) {
          var imageName, imageSizes, registry, tagName;
          registry = arg.registry, imageName = arg.imageName, tagName = arg.tagName;
          imageSizes = {};
          return registry.getImageId(imageName, tagName).then(function(imageId) {
            return registry.getImageHistory(imageId);
          }).map(function(layerId) {
            return _this.imageExists(layerId).then(function(exists) {
              if (exists) {
                return 0;
              }
              return registry.getImageDownloadSize(layerId);
            }).then(function(size) {
              return imageSizes[layerId] = size;
            });
          })["return"](imageSizes);
        };
      })(this));
    };

    DockerProgres.prototype.pullProgress = function(image, onProgress) {
      return this.getLayerDownloadSizes(image).then(function(layerSizes) {
        var completedSize, currentSize, totalSize;
        currentSize = 0;
        completedSize = 0;
        totalSize = _.sum(layerSizes);
        return function(evt) {
          var downloadedSize, longId, percentage, shortId, status;
          status = evt.status;
          if (status === 'Downloading') {
            currentSize = evt.progressDetail.current;
          } else if (status === 'Download complete') {
            shortId = evt.id;
            longId = _.findKey(layerSizes, function(v, id) {
              return _.startsWith(id, shortId);
            });
            if (longId != null) {
              completedSize += layerSizes[longId];
              currentSize = 0;
              layerSizes[longId] = 0;
            } else {
              console.warn("Progress error: Unknown layer " + shortId + " downloaded by docker. Progress not correct.");
              totalSize = null;
            }
          }
          downloadedSize = completedSize + currentSize;
          percentage = calculatePercentage(downloadedSize, totalSize);
          return onProgress(_.merge(evt, {
            downloadedSize: downloadedSize,
            totalSize: totalSize,
            percentage: percentage
          }));
        };
      });
    };

    DockerProgres.prototype.pushProgress = function(image, onProgress) {
      image = this.docker.getImage(image);
      return Promise.join(image.historyAsync(), image.inspectAsync(), function(layers, lastLayer) {
        var completedSize, currentSize, layerSizes, totalSize;
        layers.push(lastLayer);
        layerSizes = _(layers).indexBy('Id').mapValues('Size').value();
        currentSize = 0;
        completedSize = 0;
        totalSize = _.sum(layerSizes);
        return function(evt) {
          var current, longId, match, percentage, pushedSize, ref, shortId, status, total;
          status = evt.status;
          if (status === 'Pushing' && (evt.progressDetail.current != null)) {
            currentSize = evt.progressDetail.current;
          } else if (status === 'Buffering to disk') {
            evt.progressDetail.total = _.find(layerSizes, function(v, id) {
              return _.startsWith(id, evt.id);
            });
            ref = evt.progressDetail, current = ref.current, total = ref.total;
            current = humanize.filesize(current);
            total = _.isNaN(total) ? 'Unknown' : humanize.filesize(total);
            evt.progress = status + " " + current + " / " + total;
          } else {
            if (status === 'Image successfully pushed') {
              shortId = evt.id;
            } else {
              match = /Image (.*) already pushed/.exec(status);
              if (match) {
                shortId = match[1];
              }
            }
            if (shortId) {
              longId = _.findKey(layerSizes, function(v, id) {
                return _.startsWith(id, shortId);
              });
              if (longId != null) {
                completedSize += layerSizes[longId];
                currentSize = 0;
                layerSizes[longId] = 0;
              } else {
                console.warn("Progress error: Unknown layer " + shortId + " downloaded by docker. Progress not correct.");
                totalSize = null;
              }
            }
          }
          pushedSize = completedSize + currentSize;
          percentage = calculatePercentage(pushedSize, totalSize);
          return onProgress(_.merge(evt, {
            pushedSize: pushedSize,
            totalSize: totalSize,
            percentage: percentage
          }));
        };
      });
    };

    return DockerProgres;

  })();

}).call(this);
